
# coding: utf-8

# # Online Stage Transient

# ## Imports

# In[1]:


# Imports
import numpy as np
import scipy.linalg as la
# for reading the libMesh binary data files
import xdrlib
from time import time

# from numba import jit
# ## Functions

# In[2]:


def read_offline_data(path_offline_data, q_a, q_f, q_l, n_outputs):
    """This method is responsible for reading all offline data that are necessary for
       calculating the output of interest without the output error bounds.
       
       Args:
            path_offline_data = path to the offline data folder
            q_a = number of stiffness matrices (A)
            q_f = number of load vectors (f)
            q_l = number of attached theta objects to each output vector
            n_outputs = number of output vectors (l)
           
        Returns:
            n_bfs = number of basis functions
            RB_Aq = reduced stiffness matrices
            RB_Fq = reduced load vectors
            RB_Oq = reduced load vectors
           
        """
    # number of basis functions
    f = open(path_offline_data + '/n_bfs.xdr', 'rb').read()
    n_bfs = xdrlib.Unpacker(f).unpack_int()

    # RB_Aq
    RB_Aq = np.ndarray([n_bfs, n_bfs, q_a])
    for i in range(q_a):
        f = open(path_offline_data + '/RB_A_00' + str(i) + '.xdr', 'rb').read()
        u = xdrlib.Unpacker(f)
        RB_Aq[:,:,i] = np.reshape(u.unpack_farray(n_bfs*n_bfs,u.unpack_double), [n_bfs,n_bfs])
    
    # RB_Fq
    RB_Fq = np.ndarray([n_bfs, q_f])
    for i in range(q_f):
        f = open(path_offline_data + '/RB_F_00' + str(i) + '.xdr', 'rb').read()
        u = xdrlib.Unpacker(f)
        RB_Fq[:,i] = u.unpack_farray(n_bfs,u.unpack_double)
        
    # RB_Oq
    RB_Oq = np.ndarray([n_bfs, n_outputs, q_l])
    for i in range(n_outputs):
        for j in range(q_l):
            if(i<10):
                f = open(path_offline_data + '/output_00' + str(i) + '_00' + str(j)
                     + '.xdr', 'rb').read()
            if(i>=10):
                f = open(path_offline_data + '/output_0' + str(i) + '_00' + str(j)
                     + '.xdr', 'rb').read()
            u = xdrlib.Unpacker(f)
            RB_Oq[:,i,j] = u.unpack_farray(n_bfs,u.unpack_double)

    
    return (n_bfs, RB_Aq, RB_Fq, RB_Oq)


# In[3]:


def read_error_offline_data(path_offline_data, q_a, q_f, q_l, n_outputs, online_N):
    """This method is responsible for reading all offline data that are additionally necessary 
       for calculating the output error bounds.
       
       Args:
            path_offline_data = path to the offline data folder
            q_a = number of stiffness matrices (A)
            q_f = number of load vectors (f)
            q_l = number of attached theta objects to each output vector
            n_outputs = number of output vectors (l)
            online_N = the number of basis functions that should be considered
           
        Returns:
            Fq_representor_innerprods = the innerproducts from Fq-Fq
            Fq_Aq_representor_innerprods = the innerproducts from Fq-Aq
            Aq_Aq_representor_innerprods = the innerproducts from Aq-Aq
            output_dual_innerprods = the innerproducts from output-output
           
        """
    
    f = open(path_offline_data + '/Fq_innerprods.xdr', 'rb').read()
    u = xdrlib.Unpacker(f)
    Fq_representor_innerprods = np.zeros([int(q_f*(q_f+1)/2),1])
    Fq_representor_innerprods = np.reshape(u.unpack_farray(int(q_f*(q_f+1)/2),u.unpack_double),
                                           [int(q_f*(q_f+1)/2),1])
            
    Fq_Aq_representor_innerprods = np.zeros([q_f,q_a,online_N])
    f = open(path_offline_data + '/Fq_Aq_innerprods.xdr', 'rb').read()
    u = xdrlib.Unpacker(f)
    Fq_Aq_representor_innerprods = np.reshape(
                        u.unpack_farray(q_f*q_a*online_N,u.unpack_double), [q_f,q_a,online_N])
            
    Aq_Aq_representor_innerprods = np.zeros([int(q_a*(q_a+1)/2),online_N, online_N])
    f = open(path_offline_data + '/Aq_Aq_innerprods.xdr', 'rb').read()
    u = xdrlib.Unpacker(f)
    Aq_Aq_representor_innerprods = np.reshape(
                        u.unpack_farray(int(q_a*(q_a+1)/2)*online_N*online_N,u.unpack_double), 
                            [int(q_a*(q_a+1)/2),online_N, online_N])
        
    output_dual_innerprods = np.zeros([n_outputs, int(q_l*(q_l+1)/2)])
    for i in range(n_outputs):
        if(i<10):
            f = open(path_offline_data + '/output_00' + str(i) +
                    '_dual_innerprods.xdr', 'rb').read()
        if(i>=10):
            f = open(path_offline_data + '/output_0' + str(i) +
                    '_dual_innerprods.xdr', 'rb').read()
        u = xdrlib.Unpacker(f)
        output_dual_innerprods[i,:] = u.unpack_farray(int(q_l*(q_l+1)/2),u.unpack_double)
    
    return (Fq_representor_innerprods, Fq_Aq_representor_innerprods, 
            Aq_Aq_representor_innerprods, output_dual_innerprods)


# In[4]:

# @profile
def read_transient_offline_data(path_transient_offline_data, q_m, n_bfs,
                                parameter_dependent_IC = False, q_ic = 0):
    """This method is responsible for reading all offline data that are
       additionally necessary for the transient output of interest without the
       output error bounds.

       Args:
            path_offline_data = path to the transient offline data folder
            q_m = number of mass matrices (M)
            n_bfs = number of basis functions
            parameter_dependent_IC = determines whether the initial conditions
                                     are parameter dependent or note
            q_ic = number of intial conditions (IC)

        Returns:
            RB_Mq = reduced mass matrices
            initial_conditions = initial conditions
            RB_L2_matrix = reduced L2 matrix (only returned if
                           parameter_dependent_IC = True)

        """

    # RB_Mq
    RB_Mq = np.ndarray([n_bfs, n_bfs, q_m])
    if(parameter_dependent_IC==True):
        initial_conditions = np.ndarray([n_bfs, q_ic])
        RB_L2_matrix = np.ndarray([n_bfs, n_bfs])

    for i in range(q_m):
        f = open(path_transient_offline_data + '/RB_M_00' + str(i) +
                 '.xdr', 'rb').read()
        u = xdrlib.Unpacker(f)
        RB_Mq[:,:,i] = np.reshape(u.unpack_farray(n_bfs*n_bfs,u.unpack_double),
                                  [n_bfs,n_bfs])

    # intial conditions
    # currently it is only supported if online_N = n_bfs
    if(parameter_dependent_IC == False):
        print("parameter_dependent_IC == False, so reading initial_conditions.xdr") ### new
        initial_conditions = np.ndarray([n_bfs,1])
        f = open(path_transient_offline_data + '/initial_conditions.xdr', 'rb').read()
        u = xdrlib.Unpacker(f)
        initial_conditions = u.unpack_farray(n_bfs,u.unpack_double)

        return (RB_Mq, initial_conditions, None) ### Changed

    else:
        print("parameter_dependent_IC == True, so loading RB_IC_00x.xdr and RB_L2_matrix.xdr")
        for i in range(q_ic):
            f = open(path_transient_offline_data + '/RB_IC_00' + str(i) +
                     '.xdr', 'rb').read()
            u = xdrlib.Unpacker(f)
            initial_conditions[:,i] = u.unpack_farray(n_bfs,u.unpack_double)

        f = open(path_transient_offline_data + '/RB_L2_matrix.xdr', 'rb').read()
        u = xdrlib.Unpacker(f)
        RB_L2_matrix = np.reshape(u.unpack_farray(n_bfs*n_bfs, u.unpack_double),
                                       [n_bfs,n_bfs])

        return (RB_Mq, initial_conditions, RB_L2_matrix)


# In[5]:

# @profile
def read_transient_error_offline_data(path_transient_offline_data, n_bfs, q_a,
                                      q_m, q_f):
    """This method is responsible for reading all offline data that are
       additionally necessary for the transient output of interest with the
       output error bounds.

       Args:
            path_offline_data = path to the transient offline data folder
            n_bfs = number of basis functions
            q_a = number of stiffness matrices (A)
            q_m = number of mass matrices (M)
            q_f = number of load vectors (f)

        Returns:
            initial_L2_error = initial L2 error
            Fq_Mq_representor_innerprods = the innerproducts from Fq-Mq
            Aq_Mq_representor_innerprods = the innerproducts from Aq-Mq
            Mq_Mq_representor_innerprods = the innerproducts from Mq-Mq

        """
    # intial L2 error
    # currently it is only supported if online_N = n_bfs
    f = open(path_transient_offline_data + '/initial_L2_error.xdr', 'rb').read()
    u = xdrlib.Unpacker(f)
    initial_L2_error = u.unpack_farray(n_bfs,u.unpack_double)
    initial_L2_error = initial_L2_error[-1]

    Fq_Mq_representor_innerprods = np.zeros([q_f,q_m,n_bfs])
    f = open(path_transient_offline_data + '/Fq_Mq_terms.xdr', 'rb').read()
    u = xdrlib.Unpacker(f)
    Fq_Mq_representor_innerprods = np.reshape(
                        u.unpack_farray(q_f*q_m*n_bfs,u.unpack_double),
                                        [q_f,q_m,n_bfs])

    Aq_Mq_representor_innerprods = np.zeros([q_a, q_m, n_bfs, n_bfs])
    f = open(path_transient_offline_data + '/Aq_Mq_terms.xdr', 'rb').read()
    u = xdrlib.Unpacker(f)
    Aq_Mq_representor_innerprods = np.reshape(
                                u.unpack_farray(q_a*q_m*n_bfs*n_bfs,
                                                u.unpack_double),
                                                [q_a, q_m ,n_bfs, n_bfs])

    Mq_Mq_representor_innerprods = np.zeros([int(q_m*(q_m+1)/2),n_bfs, n_bfs])
    f = open(path_transient_offline_data + '/Mq_Mq_terms.xdr', 'rb').read()
    u = xdrlib.Unpacker(f)
    Mq_Mq_representor_innerprods = np.reshape(
                        u.unpack_farray(int(q_m*(q_m+1)/2)*n_bfs*n_bfs,
                                        u.unpack_double),
                                        [int(q_m*(q_m+1)/2),n_bfs, n_bfs])

    return (initial_L2_error, Fq_Mq_representor_innerprods,
            Aq_Mq_representor_innerprods, Mq_Mq_representor_innerprods)


# In[6]:

# @jit(nopython=True)
def compute_residual_dual_norm(Fq_inner, Fq_Aq_inner, Aq_Aq_inner, q_a, q_f, 
                               online_mu_parameters, online_N, RB_solution):
    """This method is responsible for computing the residual dual norm.
       
       Args:
            Fq_inner = the innerproducts from Fq-Fq
            Fq_Aq_inner = the innerproducts from Fq-Aq
            Aq_Aq_inner = the innerproducts from Aq-Aq
            q_a = number of stiffness matrices (A)n_bfs
            q_f = number of load vectors (f)
            online_mu_parameters = online parameters
            online_N = the number of basis functions that should be considered
            RB_solution = reduced solution vector
           
        Returns:
            residual_norm_sq = the square root of the residual dual norm
           
        """
    residual_norm_sq = 0.
    q=0
    for q_f1 in range(q_f):
        for q_f2 in range(q_f1, q_f):
            if(q_f1==q_f2):
                delta = 1.
            else:
                delta = 2.
            
            residual_norm_sq += delta*np.real(theta_F(online_mu_parameters)[q_f1]*
                                              np.conj(theta_F(online_mu_parameters)[q_f2])*
                                                      Fq_inner[q])
            q +=1
#     residual_norm_sq = 0.
#     q=0
#     delta = [1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,1,2,2,2,1,2,2,1,2,1]
#     for q_f1 in range(q_f):            
#         residual_norm_sq += sum(theta_F(online_mu_parameters)[q_f1]*
#                             np.dot(np.multiply(delta[q_f1:q_f],
#                                    theta_F(online_mu_parameters)[q_f1:q_f]),
#                                    Fq_inner[q:q+(q_f-q_f1)]))
#         q+=q_f-q_f1
    
    for q_f1 in range(q_f):
        for q_a1 in range(q_a):
             residual_norm_sq += 2.*np.real(theta_F(online_mu_parameters)[q_f1]*
                                    np.conj(theta_A(online_mu_parameters)[q_a1])*
                                    np.dot(np.transpose(RB_solution),Fq_Aq_inner[q_f1][q_a1]))
                    
    q=0
    for q_a1 in range(q_a):
        for q_a2 in range(q_a1, q_a):
            if(q_a1==q_a2):
                delta = 1.
            else:
                delta = 2.
            residual_norm_sq +=delta*np.real(np.conj(
                                        theta_A(online_mu_parameters)[q_a1])*
                                        theta_A(online_mu_parameters)[q_a2]*
                                        np.sum(RB_solution * np.transpose(RB_solution)*
                                               np.transpose(Aq_Aq_inner[q])))
            q +=1

    
    if(np.real(residual_norm_sq)<0.):
        residual_norm_sq = abs(residual_norm_sq)
        
    return np.sqrt(residual_norm_sq)

# @jit(nopython=True)
def eval_output_dual_norm(output_id, q_l, online_mu_parameters, output_innerprods):
    """This method is responsible for evaluating the output dual norm.

       Args:
            output_id = the output for which the dual norm should be calcualted
            q_l = number of attached theta objects for each output vector
            online_mu_parameters = online parameters
            output_innerprods = the innerproducts from output-output

        Returns:
            output_bound_sq = the square root of the output dual norm

        """
    ### Test the timecost of calling theta_O: 2.6702880859375e-05s
    # st_time = time.time()
    theta_O_res = theta_O(online_mu_parameters) # new 
    # print("Calling theta_O once used {}s\n".format(time.time()-st_time))

    output_col_id = output_innerprods[output_id] # new
    output_bound_sq = 0.
    q = 0
    "q_l is 1 now"
    # print("q_l in function eval_output_dual_norm is {}".format(q_l))
    for q_l1 in range(q_l):
        for q_l2 in range(q_l1, q_l):
            if(q_l1==q_l2):
                delta = 1.
            else:
                delta = 2.

            output_bound_sq += delta*np.real(np.conj(theta_O_res[output_id]) *\
                            theta_O_res[output_id] * output_col_id[q])

            q +=1

    return np.sqrt(output_bound_sq)

# @jit(nopython=True)
def eval_output_dual_norm_new(delta_vec, theta_O_vec, output_innerprods):
    # print("output_innerprods shape: {}".format(output_innerprods.shape))
    # print("delta_vec shape: {}".format(delta_vec.shape))
    # print("theta_O_vec shape: {}".format(theta_O_vec.shape))
    # output_innerprods shape: (80, 1)
    # delta_vec shape: (55,)
    # theta_O_vec shape: (80, 1)

    theta_O_conj = np.conj(theta_O_vec)
    theta_O_conj_theta_O = np.conj(theta_O_vec) * theta_O_vec
    # print("theta_O_conj_theta_O shape is {}".format(theta_O_conj_theta_O.shape))
    # temp_1 = theta_O_conj_theta_O*output_innerprods
    # print("theta_O_conj_theta_O*output_innerprods type: {}, shape: {}".format(type(temp_1), temp_1.shape))
    # print("delta_vec type: {}, shape: {}".format(type(delta_vec), delta_vec.shape))
    return np.sqrt(np.dot(theta_O_conj_theta_O*output_innerprods, delta_vec))[:,0]


def eval_output_dual_norm_np(delta_vec, theta_O_conj_theta_O, output_innerprods):
    # print("output_innerprods shape: {}".format(output_innerprods.shape))
    # print("delta_vec shape: {}".format(delta_vec.shape))
    # print("theta_O_vec shape: {}".format(theta_O_vec.shape))
    # output_innerprods shape: (80, 1)
    # delta_vec shape: (55,)
    # theta_O_vec shape: (80, 1)


    # print("theta_O_conj_theta_O shape is {}".format(theta_O_conj_theta_O.shape))
    # temp_1 = theta_O_conj_theta_O*output_innerprods
    # print("theta_O_conj_theta_O*output_innerprods type: {}, shape: {}".format(type(temp_1), temp_1.shape))
    # print("delta_vec type: {}, shape: {}".format(type(delta_vec), delta_vec.shape))
    return np.sqrt(np.dot(theta_O_conj_theta_O*output_innerprods, delta_vec))[:,0]

# @profile
# @jit(nopython=True)
def cache_online_residual_terms(online_N, q_a, q_m, q_f, Fq_inner, Fq_Aq_inner, Aq_Aq_inner,
                                Fq_Mq_inner, Aq_Mq_inner, Mq_Mq_inner, online_mu_parameters):

    """This method is responsible for caching the online residual terms.

       Args:
            online_N = the number of basis functions that should be considered
            q_a = number of stiffness matrices (A)
            q_m = number of mass matrices (M)
            q_f = number of load vectors (f)
            Fq_inner = the innerproducts from Fq-Fq
            Fq_Aq_inner = the innerproducts from Fq-Aq
            Aq_Aq_inner = the innerproducts from Aq-Aq
            Fq_Mq_inner = the innerproducts from Fq-Mq
            Aq_Mq_inner = the innerproducts from Aq-Mq
            Mq_Mq_inner = the innerproducts from Mq-Mq
            online_mu_parameters = online parameters

        Returns:
            cached_Fq_term = Fq contribution to residual dual norm
            cached_Fq_Aq_vector = Fq-Aq contribution to residual dual norm
            cached_Aq_Aq_matrix = Aq-Aq contribution to residual dual norm
            cached_Fq_Mq_vector = Fq-Mq contribution to residual dual norm
            cached_Aq_Mq_matrix = Aq-Mq contribution to residual dual norm
            cached_Mq_Mq_matrix = Mq-Mq contribution to residual dual norm

    """
    # Imports
    cached_Fq_term = 0
    q=0
    for q_f1 in range(q_f):
        for q_f2 in range(q_f1, q_f):
            if(q_f1==q_f2):
                delta = 1.
            else:
                delta = 2.

            cached_Fq_term += delta*theta_F(online_mu_parameters)[q_f1]*theta_F(online_mu_parameters)[q_f2]*Fq_inner[q]
            q +=1


    cached_Fq_Aq_vector = np.zeros([online_N,1])
    for q_f1 in range(q_f):
        for q_a1 in range(q_a):
            for i in range(online_N):
                delta = 2.

                cached_Fq_Aq_vector[i] += delta*theta_F(online_mu_parameters)[q_f1]*theta_A(online_mu_parameters)[q_a1] * Fq_Aq_inner[q_f1][q_a1][i]


    cached_Aq_Aq_matrix = np.zeros([online_N, online_N])
    q=0
    for q_a1 in range(q_a):
        for q_a2 in range(q_a1, q_a):
            if(q_a1==q_a2):
                delta = 1.
            else:
                delta = 2.

            for i in range(online_N):
                for j in range(online_N):
                    cached_Aq_Aq_matrix[i,j] += delta*theta_A(online_mu_parameters)[q_a1]*theta_A(online_mu_parameters)[q_a2]*Aq_Aq_inner[q][i][j]
            q +=1


    cached_Fq_Mq_vector = np.zeros([online_N,1])
    for q_f1 in range(q_f):
        for q_m1 in range(q_m):
            for i in range(online_N):
                delta = 2.

                cached_Fq_Mq_vector[i] += delta*theta_F(online_mu_parameters)[q_f1]*theta_M(online_mu_parameters)[q_m1]*Fq_Mq_inner[q_f1][q_m1][i]


    cached_Aq_Mq_matrix = np.zeros([online_N, online_N])
    for q_a1 in range(q_a):
        for q_m1 in range(q_m):
            delta = 2.

            for i in range(online_N):
                for j in range(online_N):
                    cached_Aq_Mq_matrix[i,j] += delta*theta_A(online_mu_parameters)[q_a1]*theta_M(online_mu_parameters)[q_m1]*Aq_Mq_inner[q_a1][q_m1][i][j]


    cached_Mq_Mq_matrix = np.zeros([online_N, online_N])
    q=0
    for q_m1 in range(q_m):
        for q_m2 in range(q_m1, q_m):
            if(q_m1==q_m2):
                delta = 1.
            else:
                delta = 2.

            for i in range(online_N):
                for j in range(online_N):
                    cached_Mq_Mq_matrix[i,j] += delta*theta_M(online_mu_parameters)[q_m1]*theta_M(online_mu_parameters)[q_m2]*Mq_Mq_inner[q][i][j]
            q +=1


    return(cached_Fq_term, cached_Fq_Aq_vector, cached_Aq_Aq_matrix, cached_Fq_Mq_vector,
           cached_Aq_Mq_matrix, cached_Mq_Mq_matrix)


# In[9]:delta_vec

# @profile
# @jit(nopython=True)
def compute_transient_residual_dual_norm(dt, euler_theta, current_timestep, online_N,
                                         RB_solution, old_RB_solution, cached_Fq_term,
                                         cached_Fq_Aq_vector, cached_Aq_Aq_matrix,
                                         cached_Fq_Mq_vector, cached_Aq_Mq_matrix,
                                         cached_Mq_Mq_matrix):

    """This method is responsible for computing the transient residual dual norm.

       Args:
           dt = time step size
           euler_theta = Time stepping scheme
           current_timestep = current time step
           RB_solution = reduced solution vector
           old_RB_solution = old reduced solution vector
           cached_Fq_term = Fq contribution to residual dual norm
           cached_Fq_Aq_vector = Fq-Aq contribution to residual dual norm
           cached_Aq_Aq_matrix = Aq-Aq contribution to residual dual norm
           cached_Fq_Mq_vector = Fq-Mq contribution to residual dual norm
           cached_Aq_Mq_matrix = Aq-Mq contribution to residual dual norm
           cached_Mq_Mq_matrix = Mq-Mq contribution to residual dual norm

        Returns:
           residual_norm_sq = the square root of the residual dual norm

    """
    current_control = get_control(current_timestep)

    RB_u_euler_theta = np.ndarray([online_N,1])
    mass_coeff = np.ndarray([online_N,1])

    RB_u_euler_theta = np.reshape((euler_theta*RB_solution)+((1.-euler_theta)*old_RB_solution)
                                  ,[online_N,1])
    mass_coeff = -(RB_solution-np.reshape(old_RB_solution, [online_N,1]))/dt

    residual_norm_sq = current_control*current_control*cached_Fq_term
    residual_norm_sq += current_control*np.dot(RB_u_euler_theta[:,0], cached_Fq_Aq_vector[:,0])
    residual_norm_sq += current_control*np.dot(mass_coeff[:,0], cached_Fq_Mq_vector[:,0])

    residual_norm_sq += np.sum(np.dot(RB_u_euler_theta,np.transpose(RB_u_euler_theta))
                               *cached_Aq_Aq_matrix)
    residual_norm_sq += np.sum(np.dot(mass_coeff,np.transpose(mass_coeff))
                               *cached_Mq_Mq_matrix)
    residual_norm_sq += np.sum(np.dot(RB_u_euler_theta,np.transpose(mass_coeff))
                               *cached_Aq_Mq_matrix)

    if(np.real(residual_norm_sq) < 0):
        residual_norm_sq = abs(residual_norm_sq)

    return(np.sqrt(residual_norm_sq))


# In[10]:

# @jit(nopython=True)
def stability_lower_bound(online_mu_parameters):
    return min(online_mu_parameters)


# In[11]:

# @jit(nopython=True)
def theta_A (online_mu_parameters):
    return online_mu_parameters[:3]
    # return [online_mu_parameters[0], online_mu_parameters[1], online_mu_parameters[2]]


# In[12]:

# @jit(nopython=True)
def theta_F (online_mu_parameters):
    # return [1]
    return np.array([1])


# In[13]:

# @jit(nopython=True)
def theta_O (online_mu_parameters):
    return np.ones(80)
    # return [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    #         1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]


# In[14]:

# @jit(nopython=True)
def theta_M (online_mu_parameters):
    return np.array([1])
    # return [1]


# In[15]:

# @jit(nopython=True)
def theta_IC (online_mu_parameters):
    return online_mu_parameters[-1]


# In[16]:

# @jit(nopython=True)
def get_control(time_level):
    return 1.0


# In[17]:


def rb_solve_without_error_bound(online_mu_parameters, q_a, q_f, q_l, n_outputs, online_N, 
                                 RB_Aq, RB_Fq, RB_Oq):
    """This method is responsible performing the rb solve without the output error bounds.
       
       Args:
           online_mu_parameters = online parameters
           q_a = number of stiffness matrices (A)
           q_f = number of load vectors (f)
           q_l = number of attached theta objects to each output vector
           n_outputs = number of output vectors (l)
           online_N = the number of basis functions that should be considered
           RB_Aq = reduced stiffness matrices
           RB_Fq = reduced load vectors
           RB_Oq = reduced load vectors
           
        Returns:
            RB_outputs = the output of interest
           
        """
    
    # solution vector
    # RB_solution=np.array(online_N) # Deleted
    
    # assemble the RB system
    # RB_system_matrix=np.array([online_N, online_N]) ## Deleted
    RB_system_matrix = np.sum(RB_Aq*theta_A(online_mu_parameters), axis = 2)
    
    # assemble the RB rhs
    # RB_rhs= np.zeros(online_N) ## Deleted
    RB_rhs = np.sum(RB_Fq*theta_F(online_mu_parameters), axis = 1) 
    
    RB_solution = np.reshape(la.lu_solve(la.lu_factor(RB_system_matrix), RB_rhs),[online_N,1])
    
    # evaluate the RB outputs (NOTE works currently only for q_l=1)
    # RB_outputs = np.zeros(n_outputs) ## Deleted
    RB_outputs = np.sum(RB_solution*(RB_Oq[:,:,0]*theta_O(online_mu_parameters)), axis=0)

    return  (RB_outputs)


# In[18]:

# @jit(nopython=True)
def rb_solve_with_error_bound(online_mu_parameters, q_a, q_f, q_l, n_outputs, online_N, 
                              RB_Aq, RB_Fq, RB_Oq, Fq_inner, Fq_Aq_inner, Aq_Aq_inner, 
                              output_inner):
    """This method is responsible performing the rb solve with the output error bounds.
       
       Args:
           online_mu_parameters = online parameters
           q_a = number of stiffness matrices (A)
           q_f = number of load vectors (f)
           q_l = number of attached theta objects to each output vector
           n_outputs = number of output vectors (l)
           online_N = the number of basis functions that should be considered
           RB_Aq = reduced stiffness matrices
           RB_Fq = reduced load vectors
           RB_Oq = reduced load vectors
           Fq_inner = the innerproducts from Fq-Fq
           Fq_Aq_inner = the innerproducts from Fq-Aq
           Aq_Aq_inner = the innerproducts from Aq-Aq
           output_inner = the innerproducts from output-output
           
        Returns:
            RB_outputs = the output of interest
            RB_output_error_bounds = the error bounds for the output of interest
           
        """
    
    # solution vector
    RB_solution=np.zeros(online_N)
    
    # assemble the RB system
    RB_system_matrix=np.array([online_N, online_N])
    RB_system_matrix = np.sum(RB_Aq*theta_A(online_mu_parameters), axis = 2)
    
    # assemble the RB rhs
    RB_rhs= np.zeros(online_N)
    RB_rhs = np.sum(RB_Fq*theta_F(online_mu_parameters), axis = 1) 
    
    RB_solution = np.reshape(la.lu_solve(la.lu_factor(RB_system_matrix), RB_rhs),[online_N,1])
    
    # evaluate the RB outputs and corresponding errors
    epsilon_N = compute_residual_dual_norm(Fq_inner, Fq_Aq_inner, Aq_Aq_inner, q_a, q_f, 
                                               online_mu_parameters, online_N, RB_solution)
    alpha_LB = stability_lower_bound(online_mu_parameters)
        
    if(alpha_LB>0.):
        abs_error_bound = epsilon_N/alpha_LB
    else:
        print("The lower bound must be larger than 0.")
        return
        
#     RB_outputs = np.zeros(n_outputs)
    RB_output_error_bounds = np.zeros(n_outputs)
    RB_outputs = np.sum(RB_solution*(RB_Oq[:,:,0]*theta_O(online_mu_parameters)), axis=0)
    
    for i in range(n_outputs):
        RB_output_error_bounds[i]=abs_error_bound*eval_output_dual_norm(i, q_l, 
                                                                         online_mu_parameters, 
                                                                         output_inner)
    
    return (RB_outputs, RB_output_error_bounds)


# In[19]:

# @profile
def transient_rb_solve_without_error_bound(online_mu_parameters, q_a, q_m, q_f,
                                           q_l, n_outputs, online_N, n_timesteps,
                                           dt, euler_theta, RB_Aq, RB_Mq, RB_Fq,
                                           RB_Oq, initial_conditions,
                                           parameter_dependent_IC = False, q_ic = 0,
                                           RB_L2_matrix = 0):

    """This method is responsible performing the transient rb solve without the
       output error bounds.

       Args:
           online_mu_parameters = online parameters
           q_a = number of stiffness matrices (A)
           q_m = number of mass matrices (M)
           q_f = number of load vectors (f)
           q_l = number of attached theta objects to each output vector
           n_outputs = number of output vectors (l)
           online_N = the number of basis functions that should be considered
           n_timesteps = number of time steps
           dt = time step size
           euler_theta = Time stepping scheme
           RB_Aq = reduced stiffness matrices
           RB_Mq = reduced mass matrices
           RB_Fq = reduced load vectors
           RB_Oq = reduced load vectors
           initial_conditions = initial conditions
           parameter_dependent_IC = determines whether the initial conditions
                                    are parameter dependent or note
           q_ic = number of intial conditions (IC)
           RB_L2_matrix = reduced L2 matrix

        Returns:
            RB_outputs_all_k = the output of interest for all timesteps

        """
    theta_O_res = theta_O(online_mu_parameters)
    theta_O_vec = np.array(theta_O_res).reshape(-1, 1)
    RB_Oq_reshaped = RB_Oq.reshape(10,80).T

    # assemble the mass matrix
    RB_mass_matrix_N = np.zeros([online_N, online_N])
    RB_mass_matrix_N = np.sum(RB_Mq*theta_M(online_mu_parameters), axis = 2)

    # assemble LHS matrix
    # RB_LHS_matrix = np.zeros([online_N, online_N])
    RB_LHS_matrix = RB_mass_matrix_N * (1./dt)
    RB_LHS_matrix += np.sum(RB_Aq*theta_A(online_mu_parameters), axis = 2)

    # assemble RHS matrix
    # RB_RHS_matrix = np.zeros([online_N, online_N])
    RB_RHS_matrix = RB_mass_matrix_N * (1./dt)
    RB_RHS_matrix += np.sum(-(1.-euler_theta)*RB_Aq*theta_A(online_mu_parameters), axis = 2)

    # add forcing terms
    RB_RHS_save = np.zeros([online_N])
    RB_RHS_save += np.sum(RB_Fq*theta_F(online_mu_parameters), axis = 1)

    # add the intial conditions to the solution vector
    RB_solution = np.zeros([online_N,1])

    if(parameter_dependent_IC==False):
        RB_solution = initial_conditions
    else:
        RB_rhs_N= np.zeros([online_N,1]);
        RB_rhs_N += initial_conditions*theta_IC(online_mu_parameters)
        RB_solution = la.lu_solve(la.lu_factor(RB_L2_matrix), RB_rhs_N)
        RB_solution = RB_solution[:,0]

    old_RB_solution = np.zeros([online_N,1])
    RB_solution_reshaped = np.reshape(RB_solution, [online_N,1])
    # initialize the RB rhs
    RB_rhs = np.zeros([online_N,1])

    # initialize the vectors storing the solution data
    RB_temporal_solution_data = np.zeros([n_timesteps+1,online_N])

    # load the initial data
    RB_temporal_solution_data[0] = RB_solution

    # set outputs at initial time
    RB_outputs_all_k = np.zeros([n_timesteps+1, n_outputs])

    for i in range(n_outputs):
        RB_outputs_all_k[0][i] = np.sum(RB_Oq[:,i,:]*theta_O(online_mu_parameters)[i]*
                                        np.reshape(RB_solution, [online_N,1]))

    for idx_time in range(1,n_timesteps+1):
        old_RB_solution = RB_solution

        RB_rhs = np.dot(RB_RHS_matrix, old_RB_solution)

        # add forcing term
        RB_rhs += get_control(i)*RB_RHS_save

        RB_solution = la.lu_solve(la.lu_factor(RB_LHS_matrix), RB_rhs)
        RB_solution_reshaped = np.reshape(RB_solution, [online_N,1])
        # Save RB_solution for current time level
        RB_temporal_solution_data[idx_time] = RB_solution;

        RB_outputs_all_k[idx_time] = np.dot(RB_Oq_reshaped*theta_O_vec, RB_solution_reshaped).T
        # for j in range(n_outputs):
        #     RB_outputs_all_k[j][i] = np.sum(RB_Oq[:,j,:]*theta_O(online_mu_parameters)[j]*
        #                                   np.reshape(RB_solution, [online_N,1]))


    return (RB_outputs_all_k)


def transient_rb_state_solve(online_mu_parameters, q_a, q_m, q_f,
                             online_N, n_timesteps, dt, euler_theta,
                             RB_Aq, RB_Mq, RB_Fq, initial_conditions,
                             parameter_dependent_IC = False, q_ic = 0,
                             RB_L2_matrix = 0):

    """This method is responsible performing the transient rb solve without the
       output error bounds.

       Args:
           online_mu_parameters = online parameters
           q_a = number of stiffness matrices (A)
           q_m = number of mass matrices (M)
           q_f = number of load vectors (f)
           online_N = the number of basis functions that should be considered
           n_timesteps = number of time steps
           dt = time step size
           euler_theta = Time stepping scheme
           RB_Aq = reduced stiffness matrices
           RB_Mq = reduced mass matrices
           RB_Fq = reduced load vectors
           initial_conditions = initial conditions
           parameter_dependent_IC = determines whether the initial conditions
                                    are parameter dependent or note
           q_ic = number of intial conditions (IC)
           RB_L2_matrix = reduced L2 matrix

        Returns:
            RB_outputs_all_k = the output of interest for all timesteps

        """
    # assemble the mass matrix
    RB_mass_matrix_N = np.zeros([online_N, online_N])
    RB_mass_matrix_N = np.sum(RB_Mq*theta_M(online_mu_parameters), axis = 2)

    # assemble LHS matrix
    RB_LHS_matrix = np.zeros([online_N, online_N])
    RB_LHS_matrix = RB_mass_matrix_N * (1./dt)
    RB_LHS_matrix += np.sum(RB_Aq*theta_A(online_mu_parameters), axis = 2)

    # assemble RHS matrix
    RB_RHS_matrix = np.zeros([online_N, online_N])
    RB_RHS_matrix = RB_mass_matrix_N * (1./dt)
    RB_RHS_matrix += np.sum(-(1.-euler_theta)*RB_Aq*theta_A(online_mu_parameters), axis = 2)

    # add forcing terms
    RB_RHS_save = np.zeros([online_N])
    RB_RHS_save += np.sum(RB_Fq*theta_F(online_mu_parameters), axis = 1)

    # add the intial conditions to the solution vector
    RB_solution = np.zeros([online_N,1])

    if(parameter_dependent_IC==False):
        RB_solution = initial_conditions
    else:
        RB_rhs_N= np.zeros([online_N,1]);
        RB_rhs_N += initial_conditions*theta_IC(online_mu_parameters)
        RB_solution = la.lu_solve(la.lu_factor(RB_L2_matrix), RB_rhs_N)
        RB_solution = RB_solution[:,0]

    old_RB_solution = np.zeros([online_N,1])

    # initialize the RB rhs
    RB_rhs = np.zeros([online_N,1])

    # initialize the vectors storing the solution data
    RB_temporal_solution_data = np.zeros([n_timesteps+1,online_N])

    # load the initial data
    RB_temporal_solution_data[0] = RB_solution

    for i in range(1,n_timesteps+1):
        old_RB_solution = RB_solution

        RB_rhs = np.dot(RB_RHS_matrix, old_RB_solution)

        # add forcing term
        RB_rhs += get_control(i)*RB_RHS_save

        RB_solution = la.lu_solve(la.lu_factor(RB_LHS_matrix), RB_rhs)

        # Save RB_solution for current time level
        RB_temporal_solution_data[i] = RB_solution;


    return (RB_temporal_solution_data[-1])


# In[22]:

# @profile
# @jit(nopython=True)
def transient_rb_solve_with_error_bound(online_mu_parameters, q_a, q_m, q_f, q_l,
                                        n_outputs, online_N, n_timesteps, dt, euler_theta,
                                        RB_Aq, RB_Mq, RB_Fq, RB_Oq, Fq_inner, Fq_Aq_inner,
                                        Aq_Aq_inner, output_inner, Fq_Mq_inner, Aq_Mq_inner,
                                        Mq_Mq_inner, initial_conditions, initial_L2_error,
                                        parameter_dependent_IC = False, q_ic = 0,
                                        RB_L2_matrix = 0):

    """This method is responsible performing the transient rb solve with the
       output error bounds.

       Args:
           online_mu_parameters = online parameters
           q_a = number of stiffness matrices (A)
           q_m = number of mass matrices (M)
           q_f = number of load vectors (f)
           q_l = number of attached theta objects to each output vector
           n_outputs = number of output vectors (l)
           online_N = the number of basis functions that should be considered
           n_timesteps = number of time steps
           dt = time step size
           euler_theta = Time stepping scheme
           RB_Aq = reduced stiffness matrices
           RB_Mq = reduced mass matrices
           RB_Fq = reduced load vectors
           RB_Oq = reduced load vectors
           Fq_inner = the innerproducts from Fq-Fq
           Fq_Aq_inner = the innerproducts from Fq-Aq
           Aq_Aq_inner = the innerproducts from Aq-Aq
           output_inner = the innerproducts from output-output
           Fq_Mq_inner = the innerproducts from Fq-Mq
           Aq_Mq_inner = the innerproducts from Aq-Mq
           Mq_Mq_inner = the innerproducts from Mq-Mq
           initial_conditions = initial conditions
           initial_L2_error = initial L2 error

        Returns:
            RB_outputs_all_k = the output of interest for all timesteps
            RB_output_error_bounds_all_k = the error bounds for the output of interest

        """
    # eval_output_dual_norm_local = eval_output_dual_norm
    # assemble the mass matrix
    RB_mass_matrix_N = np.sum(RB_Mq*theta_M(online_mu_parameters), axis = 2)

    # assemble LHS matrix
    RB_LHS_matrix = RB_mass_matrix_N * (1./dt)
    RB_LHS_matrix += np.sum(RB_Aq*theta_A(online_mu_parameters), axis = 2)

    # assemble RHS matrix
    RB_RHS_matrix = RB_mass_matrix_N * (1./dt)
    RB_RHS_matrix += np.sum(-(1.-euler_theta)*RB_Aq*theta_A(online_mu_parameters), axis = 2)

    # add forcing terms
    RB_RHS_save = np.zeros([online_N])
    RB_RHS_save += np.sum(RB_Fq*theta_F(online_mu_parameters), axis = 1)

    # print("initial_conditions ")
    # add the intial conditions to the solution vector
    if(parameter_dependent_IC==False):
        # print("parameter_dependent_IC is False now, so RB_solution = initial_conditions\n")
        RB_solution = initial_conditions
    else:
        # print("parameter_dependent_IC is True now, so calculate RB_solution\n")
        RB_rhs_N= np.zeros([online_N,1])
        RB_rhs_N += initial_conditions*theta_IC(online_mu_parameters)
        RB_solution = la.lu_solve(la.lu_factor(RB_L2_matrix), RB_rhs_N)
        RB_solution = RB_solution[:,0]

    # print("RB_solution type: {}, length: {}".format(type(RB_solution), len(RB_solution)))

    old_RB_solution = np.zeros([online_N,1])

    # initialize the RB rhs
    RB_rhs = np.zeros([online_N,1])

    # initialize the vectors storing the solution data
    RB_temporal_solution_data = np.zeros([n_timesteps+1,online_N])

    # load the initial data
    RB_temporal_solution_data[0] = RB_solution

    # set error bounds at initial time
    error_bound_sum = 0.
    alpha_LB = 0.
    error_bound_all_k = np.zeros([n_timesteps+1,1])

    ### Initial error bound
    error_bound_sum += initial_L2_error**2
    error_bound_all_k[0] = np.sqrt(error_bound_sum)

    # set outputs at initial time
    # RB_outputs_all_k = np.zeros([n_outputs, n_timesteps+1])
    # RB_output_error_bounds_all_k = np.zeros([n_outputs, n_timesteps+1])

    # for i in range(n_outputs):
    #     RB_outputs_all_k[i][0] = np.sum(RB_Oq[:,i,:]*theta_O(online_mu_parameters)[i]*
    #                                     np.reshape(RB_solution, [online_N,1]))
    #     RB_output_error_bounds_all_k[i][0] = error_bound_all_k[0] * eval_output_dual_norm(i,
    #                                                                     q_l,
    #                                                                     online_mu_parameters,
    #                                                              output_inner)
    RB_outputs_all_k = np.zeros([n_timesteps+1, n_outputs]) # new
    RB_output_error_bounds_all_k = np.zeros([n_timesteps+1, n_outputs]) # new

    RB_solution_reshaped = np.reshape(RB_solution, [online_N,1])
    theta_O_res = theta_O(online_mu_parameters)
    theta_O_vec = np.array(theta_O_res).reshape(-1, 1)
    theta_O_conj = np.conj(theta_O_vec)
    theta_O_conj_theta_O = np.conj(theta_O_vec) * theta_O_vec
    # print("theta_O_vec shape is {}\n".format(theta_O_vec.shape))    

    ### Store initial output and error
    for idx_col in range(n_outputs):
        RB_outputs_all_k[0][idx_col] = np.sum(RB_Oq[:,idx_col,:]*theta_O_res[idx_col]*
                                        RB_solution_reshaped)
        RB_output_error_bounds_all_k[0][idx_col] = error_bound_all_k[0] * eval_output_dual_norm(idx_col,
                                                                        q_l,
                                                                        online_mu_parameters,
                                                                        output_inner)

    alpha_LB = stability_lower_bound(online_mu_parameters)

    [cached_Fq_term, cached_Fq_Aq_vector, cached_Aq_Aq_matrix, cached_Fq_Mq_vector,     cached_Aq_Mq_matrix, cached_Mq_Mq_matrix] = cache_online_residual_terms(online_N,
                                                                             q_a, q_m, q_f,
                                                                             Fq_inner,
                                                                             Fq_Aq_inner,
                                                                             Aq_Aq_inner,
                                                                             Fq_Mq_inner,
                                                                             Aq_Mq_inner,
                                                                             Mq_Mq_inner,
                                                                    online_mu_parameters)

    RB_Oq_reshaped = RB_Oq.reshape(10,80).T
    for idx_time in range(1,n_timesteps+1):
        old_RB_solution = RB_solution

        RB_rhs = np.dot(RB_RHS_matrix, old_RB_solution)

        # add forcing term
        RB_rhs += get_control(idx_time)*RB_RHS_save
        "RB_solution shape: (10,)"
        ### Update RB_solution
        RB_solution = la.lu_solve(la.lu_factor(RB_LHS_matrix), RB_rhs)
        RB_solution_reshaped = np.reshape(RB_solution, [online_N,1])
        # Save RB_solution for current time level
        RB_temporal_solution_data[idx_time] = RB_solution     

        epsilon_N = compute_transient_residual_dual_norm(dt, euler_theta, idx_time, online_N,
                                                         RB_solution_reshaped,
                                                         np.reshape(old_RB_solution,
                                                                    [online_N,1]),
                                                         cached_Fq_term, cached_Fq_Aq_vector,
                                                         cached_Aq_Aq_matrix,
                                                         cached_Fq_Mq_vector,
                                                         cached_Aq_Mq_matrix,
                                                         cached_Mq_Mq_matrix)

        error_bound_sum += dt * (epsilon_N**2)
        error_bound_all_k[idx_time] = np.sqrt(error_bound_sum/alpha_LB)

        "RB_Oq[:,j,:] shape: (10, 1)"
        "RB_Oq shape is (10, 80, 1)"
        #correct1
        RB_outputs_all_k[idx_time] = np.dot(RB_Oq_reshaped*theta_O_vec, RB_solution_reshaped).T

        '''
        Improved Approach 2 ==> Use old function with nested loop *(eval_output_dual_norm)* and list comprehension
        '''
        # output_norm = np.array([eval_output_dual_norm(idx_col, q_l, online_mu_parameters, output_inner) for idx_col in range(n_outputs)])
        # RB_output_error_bounds_all_k[idx_time] = error_bound_all_k[idx_time] * output_norm
        

        '''
        Improved Approach 3 ==> Use eval_output_dual_norm_np
        '''
        # RB_output_error_bounds_all_k[idx_time] = error_bound_all_k[idx_time] * eval_output_dual_norm_np(delta_vec, theta_O_conj_theta_O, output_inner)
        
        '''
        Improved Approach 4 ==> Use eval_output_dual_norm_new
        '''
        RB_output_error_bounds_all_k[idx_time] = error_bound_all_k[idx_time] * eval_output_dual_norm_new(delta_vec, theta_O_vec, output_inner)

        '''
        Old approach
        '''
        # for j in range(n_outputs):
        ## 12%
        ## 30.8%
        #     RB_outputs_all_k[j][i] = np.sum(RB_Oq[:,j,:]*theta_O(online_mu_parameters)[j]*
        #                                   np.reshape(RB_solution, [online_N,1]))
        ## 39.8%
        #     RB_output_error_bounds_all_k[j][i] = error_bound_all_k[i]* eval_output_dual_norm(j, q_l, online_mu_parameters, output_inner)

    return (RB_outputs_all_k, RB_output_error_bounds_all_k)


# ## Online Stage

path_offline_data = "offline_data"
q_a = 3
q_f = 1
q_l = 1
n_outputs = 80
n_timesteps = 45
dt = 1
euler_theta = 1
parameter_dependent_IC = False
q_ic = 0
q_m = 1
online_mu_parameters = [1.05, 2.38, 1.05]

num_runs = 1000

# ## Read the Data
online_N,RB_Aq,RB_Fq, RB_Oq = read_offline_data(path_offline_data, q_a, q_f, q_l, n_outputs)
# print("read_offline_data cost {}s\n".format(time()- t))

# online_N type: <class 'int'> is 10
# RB_Aq type: <class 'numpy.ndarray'>, shape: (10, 10, 3)
# RB_Fq type: <class 'numpy.ndarray'>, shape: (10, 1)
# RB_Oq type: <class 'numpy.ndarray'>, shape: (10, 80, 1)

# print("online_N type: {} is {}".format(type(online_N), online_N))
# print("RB_Aq type: {}, shape: {}".format(type(RB_Aq), RB_Aq.shape))
# print("RB_Fq type: {}, shape: {}".format(type(RB_Fq), RB_Fq.shape))
# print("RB_Oq type: {}, shape: {}".format(type(RB_Oq), RB_Oq.shape))


Fq_inner, Fq_Aq_inner, Aq_Aq_inner, output_inner = read_error_offline_data(path_offline_data,
                                                                             q_a, q_f, q_l, 
                                                                             n_outputs, online_N)
# print("read_error_offline_data used {}s\n".format(time()- t))

# Fq_inner type: <class 'numpy.ndarray'>, shape: (1, 1)
# Fq_Aq_inner type: <class 'numpy.ndarray'>, shape: (1, 3, 10)
# Aq_Aq_inner type: <class 'numpy.ndarray'>, shape: (6, 10, 10)
# output_inner type: <class 'numpy.ndarray'>, shape: (80, 1)

# print("Fq_inner type: {}, shape: {}".format(type(Fq_inner), Fq_inner.shape))
# print("Fq_Aq_inner type: {}, shape: {}".format(type(Fq_Aq_inner), Fq_Aq_inner.shape))
# print("Aq_Aq_inner type: {}, shape: {}".format(type(Aq_Aq_inner), Aq_Aq_inner.shape))
# print("output_inner type: {}, shape: {}".format(type(output_inner), output_inner.shape))


RB_Mq, initial_conditions,_ = read_transient_offline_data(path_offline_data, q_m, online_N,parameter_dependent_IC, 
                                                          q_ic)
# print("read_transient_offline_data used {}s\n".format(time()- t))

# RB_Mq (type: <class 'numpy.ndarray'>, shape: (10, 10, 1))
# Initial conditions are (type: <class 'list'>) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

# print("RB_Mq (type: {}, shape: {}) is {}".format(type(RB_Mq), RB_Mq.shape, RB_Mq[:3][0]))
# print("Initial conditions are (type: {}) {}\n".format(type(initial_conditions), initial_conditions))


initial_L2_error, Fq_Mq_inner, Aq_Mq_inner, Mq_Mq_inner = read_transient_error_offline_data(path_offline_data,
                                                                                              online_N,q_a,q_m,q_f)
# print("read_transient_error_offline_data used {}s".format(time()- t))

# initial_L2_error (read_transient_error_offline_data) is (type: <class 'float'>) 0.0
# Fq_Mq_inner type: <class 'numpy.ndarray'>, shape: (1, 1, 10)
# Aq_Mq_inner type: <class 'numpy.ndarray'>, shape: (3, 1, 10, 10)
# Mq_Mq_inner type: <class 'numpy.ndarray'>, shape: (1, 10, 10)


# print("initial_L2_error (read_transient_error_offline_data) is (type: {}) {}\n".format(type(initial_L2_error), initial_L2_error))
# print("Fq_Mq_inner type: {}, shape: {}".format(type(Fq_Mq_inner), Fq_Mq_inner.shape))
# print("Aq_Mq_inner type: {}, shape: {}".format(type(Aq_Mq_inner), Aq_Mq_inner.shape))
# print("Mq_Mq_inner type: {}, shape: {}".format(type(Mq_Mq_inner), Mq_Mq_inner.shape))


t = time()
# RB_outputs = transient_rb_solve_without_error_bound(online_mu_parameters, q_a, q_m, q_f, q_l, n_outputs, online_N, 
#                                                     n_timesteps, dt, euler_theta, RB_Aq, RB_Mq, RB_Fq, RB_Oq, 
#                                                     initial_conditions, parameter_dependent_IC = False, q_ic = 0,
#                                                     RB_L2_matrix = 0)
for idx_count in range(num_runs):
    RB_outputs = transient_rb_solve_without_error_bound(online_mu_parameters, q_a, q_m, q_f, q_l, n_outputs, online_N, 
                                                    n_timesteps, dt, euler_theta, RB_Aq, RB_Mq, RB_Fq, RB_Oq, 
                                                    initial_conditions, parameter_dependent_IC = False, q_ic = 0,
                                                    RB_L2_matrix = 0)
print("***transient_rb_solve_without_error_bound used <{:.5f}>s".format((time()- t)/num_runs))
print("RB_outputs (transient_rb_solve_without_error_bound) (shape: {})are \n\t{}".format(RB_outputs.shape, RB_outputs[2, :5]))
print("RB_outpus (transient_rb_solve_without_error_bound) (shape: {}) are \n\t{}\n".format(RB_outputs.shape, RB_outputs[4, :5]))

#correct2
delta_list = [1 if q_l1==q_l2 else 2 for q_l1 in range(10) for q_l2 in range(q_l1, q_l)]
delta_vec = np.array(delta_list, dtype=float).reshape(-1,1)
theta_O_vec = np.array(theta_O(online_mu_parameters)).T

t = time()
# [RB_outputs, RB_errors] = transient_rb_solve_with_error_bound(online_mu_parameters, q_a, q_m, q_f, q_l, n_outputs, 
#                                                                   online_N, n_timesteps, dt, euler_theta, RB_Aq, RB_Mq,
#                                                                   RB_Fq, RB_Oq, Fq_inner, Fq_Aq_inner, Aq_Aq_inner, 
#                                                                   output_inner, Fq_Mq_inner, Aq_Mq_inner, Mq_Mq_inner,
#                                                                   initial_conditions, initial_L2_error,
#                                                                   parameter_dependent_IC = False, 
#                                                                   q_ic = 0, RB_L2_matrix = 0)
for idx_count in range(num_runs):
    [RB_outputs, RB_errors] = transient_rb_solve_with_error_bound(online_mu_parameters, q_a, q_m, q_f, q_l, n_outputs, 
                                                                  online_N, n_timesteps, dt, euler_theta, RB_Aq, RB_Mq,
                                                                  RB_Fq, RB_Oq, Fq_inner, Fq_Aq_inner, Aq_Aq_inner, 
                                                                  output_inner, Fq_Mq_inner, Aq_Mq_inner, Mq_Mq_inner,
                                                                  initial_conditions, initial_L2_error,
                                                                  parameter_dependent_IC = False, 
                                                                  q_ic = 0, RB_L2_matrix = 0)
print("***transient_rb_solve_with_error_bound used <{:.5f}>s".format((time()- t)/num_runs))
print("RB_outputs (transient_rb_solve_with_error_bound) (shape: {})are \n\t{}".format(RB_outputs.shape, RB_outputs[2, :5]))
print("RB_outpus (transient_rb_solve_with_error_bound) (shape: {}) are \n\t{}\n".format(RB_outputs.shape, RB_outputs[4, :5]))
print("RB_errors (transient_rb_solve_with_error_bound) (shape: {})are \n\t{}".format(RB_errors.shape, RB_errors[2, :5]))
print("RB_errors (transient_rb_solve_with_error_bound) (shape: {})are \n\t{}\n".format(RB_errors.shape, RB_errors[4, :5]))
